<?xml version="1.0" encoding="utf-8" ?>
<DynLINQDoc xmlns="http://schemas.plainlogic.net/dynamiclinqdocs/2014">
  
  <Classes>
    <Class name="BasicQueryable" namespace="System.Linq.Dynamic">
      <Description>Provides a set of **static** methods for querying data structures that implement `IQueryable`.</Description>
      <Remarks>The purpose of this class is to mimic several basic methods implemented by the standard `System.Linq.IQueryable&lt;T&gt;`, but that work with `IQueryable`.</Remarks>
      
      <Methods>
        
        <Method name="Take" isExtensionMethod="true" returnType="IQueryable">
          <Description>Returns a specified number of contiguous elements from the start of a sequence.</Description>
          <Remarks>`Take` enumerates *source* and *yields* elements until *count* elements have been yielded or *source* contains no more elements.&#xA;&#xA;If *count* is less than or equal to zero, *source* is not enumerated and an empty `IQueryable` is returned.</Remarks>
          <ReturnDescription>A `IQueryable` that contains the specified number of elements from the start of `source`.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The sequence to return elements from.</Description>
            </Argument>
            <Argument name="count" type="int" typeNamespace="System.Int32">
              <Description>The number of elements to return.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Take(IQueryable, Int32)` to return elements from the start of a sequence.</HeaderRemarks>
              <ExampleCode>int[] grades = { 59, 82, 70, 56, 92, 98, 85 };
              
// Sort the grades in descending order and take the first three.
IEnumerable&lt;int&gt; topThreeGrades =
    grades.AsQueryable().OrderByDescending(grade => grade).Take(3);
    
Console.WriteLine("The top three grades are:");
foreach (int grade in topThreeGrades)
    Console.WriteLine(grade);
  
/*
    This code produces the following output:

    The top three grades are:
    98
    92
    85
*/</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Skip" isExtensionMethod="true" returnType="IQueryable">
          <Description>Bypasses a specified number of elements in a sequence and then returns the remaining elements.</Description>
          <ReturnDescription>A `IQueryable` that contains elements that occur after the specified index in the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The sequence to return elements from.</Description>
            </Argument>
            <Argument name="count" type="int" typeNamespace="System.Int32">
              <Description>The number of elements to skip before returning the remaining elements.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Skip(IQueryable, Int32)` to skip a specified number of elements in a sorted array and return the remaining elements.</HeaderRemarks>
              <ExampleCode>int[] grades = { 59, 82, 70, 56, 92, 98, 85 };

// Sort the grades in descending order get all except the first three.
IEnumerable&lt;int&gt; lowerGrades =
    grades.AsQueryable().OrderByDescending(grade => grade).Skip(3);

Console.WriteLine("All grades except the top three are:");
foreach (int grade in topThreeGrades)
    Console.WriteLine(grade);

/*
    This code produces the following output:

    All grades except the top three are:
    82
    70
    59
    56
*/</ExampleCode>
            </Example>
          </Examples>
        </Method>
        
        <Method name="Reverse" isExtensionMethod="true" returnType="IQueryable">
          <Description>Inverts the order of the elements in a sequence.</Description>
          <ReturnDescription>A `IQueryable` whose elements correspond to those of the input sequence in reverse order.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to reverse.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Reverse(IQueryable)` to reverse the order of elements in an array.</HeaderRemarks>
              <ExampleCode>char[] apple = { 'a', 'p', 'p', 'l', 'e' };

// Reverse the order of the characters in the collection.
IQueryable query = apple.AsQueryable();
IQueryable reversed = query.Reverse();

foreach (char chr in reversed)
    Console.Write(chr + " ");
Console.WriteLine();

/*
    This code produces the following output:

    e l p p a
*/</ExampleCode>
            </Example>
          </Examples>
        </Method>
    
        <Method name="Any" isExtensionMethod="true" returnType="bool">
          <Description>Determines whether a sequence contains any elements.</Description>
          <ReturnDescription>`true` if the source sequence contains any elements; otherwise, `false`.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence to check for being empty.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Any(IQueryable)` to determine whether a sequence contains any elements.</HeaderRemarks>
              <ExampleCode>List&lt;int&gt;
numbers = new List&lt;int&gt; { 1, 2 };

// Determine if the list contains any elements.
bool hasElements = numbers.AsQueryable().Any();

Console.WriteLine("The list {0} empty.",
    hasElements ? "is not" : "is");

// This code produces the following output:
//
// The list is not empty.</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Count" isExtensionMethod="true" returnType="int">
          <Description>Returns the number of elements in a sequence.</Description>
          <ReturnDescription>The number of elements in the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The `IQueryable` that contains the elements to be counted.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Count(IQueryable)` to count the elements in a sequence.</HeaderRemarks>
              <ExampleCode>string[] fruits = { "apple", "banana", "mango",
"orange", "passionfruit", "grape" };

int numberOfFruits = fruits.AsQueryable().Count();

Console.WriteLine(
    "There are {0} items in the array.",
    numberOfFruits);

// This code produces the following output:
//
// There are 6 items in the array.</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Single" frameworks="Net35" isExtensionMethod="true" returnType="object">
          <Description>Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.</Description>
          <ReturnDescription>The single element of the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the single element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="Single" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic">
          <Description>Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.</Description>
          <ReturnDescription>The single element of the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the single element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="SingleOrDefault" frameworks="Net35" isExtensionMethod="true" returnType="object">
          <Description>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</Description>
          <ReturnDescription>The single element of the input sequence, or `null` if the sequence contains no elements.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the single element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="SingleOrDefault" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic">
          <Description>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</Description>
          <ReturnDescription>The single element of the input sequence, or `null` if the sequence contains no elements.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the single element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="First" frameworks="Net35" isExtensionMethod="true" returnType="object">
          <Description>Returns the first element of a sequence.</Description>
          <ReturnDescription>The first element in source.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the first element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="First" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic">
          <Description>Returns the first element of a sequence.</Description>
          <ReturnDescription>The first element in source.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the first element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="FirstOrDefault" frameworks="Net35" isExtensionMethod="true" returnType="object">
          <Description>Returns the first element of a sequence, or a default value if the sequence contains no elements.</Description>
          <ReturnDescription>`null` if source is empty; otherwise, the first element in *source*.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the first element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="FirstOrDefault" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic">
          <Description>Returns the first element of a sequence, or a default value if the sequence contains no elements.</Description>
          <ReturnDescription>`null` if source is empty; otherwise, the first element in *source*.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the first element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="AsEnumerable" frameworks="Net35" isExtensionMethod="true" returnType="IEnumerable&lt;object&gt;">
          <Description>Returns the input typed as `IEnumerable&lt;T&gt;` of `object`.</Description>
          <ReturnDescription>The input typed as `IEnumerable&lt;T&gt;` of `object`.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The sequence to type as `IEnumerable&lt;T&gt;` of `object`.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="AsEnumerable" frameworks="Net40Plus" isExtensionMethod="true" returnType="IEnumerable&lt;dynamic&gt;">
          <Description>Returns the input typed as `IEnumerable&lt;T&gt;` of `dynamic`.</Description>
          <ReturnDescription>The input typed as `IEnumerable&lt;T&gt;` of `dynamic`.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The sequence to type as `IEnumerable&lt;T&gt;` of `dynamic`.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="ToDynamicArray" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic[]">
          <Description>Creates an array of `dynamic` `objects` from a `IEnumerable`.</Description>
          <ReturnDescription>An array that contains the elements from the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to create an array from.</Description>
            </Argument>
          </Arguments>
        </Method>
        
      </Methods>
    </Class>  <!--BasicQueryable-->

    <Class name="DynamicQueryable" namespace="System.Linq.Dynamic">
      <Description>Provides a set of **static** methods for querying data structures that implement `IQueryable`. It allows dynamic string based querying.  Very handy when, at compile time, you don't know the type of queries that will be generated, or when downstream components only return column names to sort and filter by.</Description>
      <Remarks></Remarks>

      <Methods>
        <Method name="Where&lt;TSource&gt;" isExtensionMethod="true" returnType="IQueryable&lt;TSource&gt;" hasParamsArgument="true">
          <Description>Filters a sequence of values based on a predicate.</Description>
          <ReturnDescription>A `IQueryable&lt;TSource&gt;` that contains elements from the input sequence that satisfy the condition specified by predicate.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable&lt;TSource&gt;" typeNamespace="System.Linq">
              <Description>A `IQueryable` to filter.</Description>
            </Argument>
            <Argument name="predicate" type="string" typeNamespace="System">
              <Description>An expression string to test each element for a condition.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a *basic value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>List&lt;string&gt; fruits =
    new List&lt;string> { "apple", "passionfruit", "banana", "mango", 
                        "orange", "blueberry", "grape", "strawberry" };

// Get all strings whose length is less than 6.
IEnumerable query = fruits.AsQueryable().Where("fruit.Length &lt; 6");

foreach (string fruit in query)
    Console.WriteLine(fruit);

/*
    This code produces the following output:

    apple
    mango
    grape
*/</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *static argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", 1);</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *variable argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>int someValue = 6;
 
IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", someValue);</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Where" isExtensionMethod="true" returnType="IQueryable" hasParamsArgument="true">
          <Description>Filters a sequence of values based on a predicate.</Description>
          <ReturnDescription>A `IQueryable` that contains elements from the input sequence that satisfy the condition specified by predicate.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to filter.</Description>
            </Argument>
            <Argument name="predicate" type="string" typeNamespace="System">
              <Description>An expression string to test each element for a condition.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a *basic value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>List&lt;string&gt; fruits =
    new List&lt;string> { "apple", "passionfruit", "banana", "mango", 
                        "orange", "blueberry", "grape", "strawberry" };

// Get all strings whose length is less than 6.
IEnumerable query = fruits.AsQueryable().Where("fruit.Length &lt; 6");

foreach (string fruit in query)
    Console.WriteLine(fruit);

/*
    This code produces the following output:

    apple
    mango
    grape
*/</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *static argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", 1);</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *variable argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>int someValue = 6;
 
IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", someValue);</ExampleCode>
            </Example>
          </Examples>
        </Method>
        
        <Method name="Select" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable">
          <Description>Projects each element of a sequence into a new form.</Description>
          <ReturnDescription>An `IQueryable` whose elements are the result of invoking a projection string on each element of *source*.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to project.</Description>
            </Argument>
            <Argument name="selector" type="string" typeNamespace="System">
              <Description>A projection string expression to apply to each element.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Select` to project over a sequence of values, using the `it` keyword.</HeaderRemarks>
              <ExampleCode>List&lt;int&gt; range =
    new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Project the square of each int value.
IEnumerable squares =
    range.AsQueryable().Select("it * it");

foreach (int num in squares)
    Console.WriteLine(num);

/*
    This code produces the following output:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100
*/</ExampleCode>
              <EquivalentCode>List&lt;int&gt; range =
    new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Project the square of each int value.
IEnumerable&lt;int&gt; squares =
    range.AsQueryable().Select(x => x * x);

foreach (int num in squares)
    Console.WriteLine(num);

/*
    This code produces the following output:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100
*/</EquivalentCode>
            </Example>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Select` to project a single field and a group of fields over a sequence of values.</HeaderRemarks>
              <ExampleCode>class ExampleClass
{
    public string StringProperty1 { get; set; }
    public string StringProperty2 { get; set; }
}

//Select a single field
var singleField = qry.Select("StringProperty");
    
//Select a group of fields
var dynamicObject = qry.Select("new (StringProperty1, StringProperty2 as OtherStringPropertyName)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="SelectMany" isExtensionMethod="true">
          <Description>Placeholder</Description>
        </Method>

        <Method name="OrderBy&lt;TSource&gt;" isExtensionMethod="true">
          <Description>Placeholder</Description>
        </Method>

        <Method name="OrderBy" isExtensionMethod="true">
          <Description>Placeholder</Description>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" hasParamsArgument="true">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A string expression to specify a result value from each group.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true">
          <Description>Placeholder</Description>        
        </Method>

        <Method name="GroupBy" isExtensionMethod="true">
          <Description>Placeholder</Description>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true">
          <Description>Placeholder</Description>
        </Method>

        <Method name="GroupByMany&lt;TElement&gt;" isExtensionMethod="true" hasParamsArgument="true">
          <Description>Groups the elements of a sequence according to multiple specified key string functions and creates a result value from each group (and subgroups) and its key.</Description>
          <ReturnDescription>A `IEnumerable&lt;GroupResult&gt;` where each element represents a projection over a group, its key, and its subgroups.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IEnumerable&lt;TElement&gt;" typeNamespace="System.Collections.Generic">
              <Description>A `IEnumerable&lt;TElement&gt;` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelectors" type="string[]" typeNamespace="System">
              <Description>`string` expressions to specify the keys for each element.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="GroupByMany&lt;TElement&gt;" isExtensionMethod="true" hasParamsArgument="true">
          <Description>Groups the elements of a sequence according to multiple specified key string functions and creates a result value from each group (and subgroups) and its key.</Description>
          <ReturnDescription>A `IEnumerable&lt;GroupResult&gt;` where each element represents a projection over a group, its key, and its subgroups.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IEnumerable&lt;TElement&gt;" typeNamespace="System.Collections.Generic">
              <Description>A `IEnumerable&lt;TElement&gt;` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelectors" type="Func&lt;TElement,object&gt;[]" typeNamespace="System">
              <Description>Lambda expressions to specify the keys for each element.</Description>
            </Argument>
          </Arguments>
        </Method>
      </Methods>
    </Class>

    <Class name="ParseException" namespace="System.Linq.Dynamic">
      <Description>Represents errors that occur while parsing dynamic linq string expressions.</Description>
    </Class>

    <Class name="GroupResult" namespace="System.Linq.Dynamic">
      <Description>The result of a call to `DynamicQueryable.GroupByMany()`.</Description>
      <Properties>
        <Property name="Key" valueType="object" frameworks="Net35" accessors="Get">
          <Description>The key value of the group.</Description>
        </Property>
        <Property name="Key" valueType="dynamic" frameworks="Net40Plus" accessors="Get">
          <Description>The key value of the group.</Description>
        </Property>
        <Property name="Count" valueType="int" accessors="Get">
          <Description>The number of resulting elements in the group.</Description>
        </Property>
        <Property name="Items" valueType="int" accessors="Get">
          <Description>The resulting elements in the group.</Description>
        </Property>
        <Property name="Subgroups" valueType="int" accessors="Get">
          <Description>The resulting subgroups in the group.</Description>
        </Property>
      </Properties>
      <Methods>
        <Method name="ToString" returnType="string">
          <Description>Returns a string showing the key of the group and the number of items in the group.</Description>
        </Method>
      </Methods>
    </Class>

    <Class name="DynamicLinqTypeAttribute" namespace="System.Linq.Dynamic">
      <Description>Indicates to Dynamic Linq to consider the Type as a valid dynamic linq type. Use only when `GlobalConfig.CustomTypeProvider` is set to `DefaultDynamicLinqCustomTypeProvider`.</Description>
    </Class>

    <Class name="DefaultDynamicLinqCustomTypeProvider" namespace="System.Linq.Dynamic">
      <Description>The default `IDynamicLinkCustomTypeProvider`. Scans the current `AppDomain` for all types marked with `DynamicLinqTypeAttribute`, and adds them as custom Dynamic Link types.</Description>
      <Methods>
        <Method name="GetCustomTypes" returnType="HashSet&lt;Type&gt;">
          <Description>Returns a list of custom types that Dynamic Linq will understand.</Description>
        </Method>
      </Methods>
    </Class>

    <Class name="IDynamicLinkCustomTypeProvider" namespace="System.Linq.Dynamic" isInterface="true">
      <Description>Interface for providing custom types for Dynamic Linq.</Description>
      <Methods>
        <Method name="GetCustomTypes" returnType="HashSet&lt;Type&gt;">
          <Description>Returns a list of custom types that Dynamic Linq will understand.</Description>
        </Method>
      </Methods>
    </Class>

    <Class name="GlobalConfig" namespace="System.Linq.Dynamic">
      <Description>Static configuration class for Dynamic Linq.</Description>
      <Remarks>`GlobalConfig` is a static class for setting `AppDomain` level settings for the *Dynamic Linq Library*.</Remarks>
      <Properties>
        <Property name="CustomTypeProvider" valueType="IDynamicLinqCustomTypeProvider" accessors="GetSet" isStatic="true">
          <Description>Gets or sets the `IDynamicLinkCustomTypeProvider`.</Description>
          <ValueTypeDescription>A value that determines how custom types for Dynamic Linq are provided. The default value is set to `DefaultDynamicLinqCustomTypeProvider`.</ValueTypeDescription>
        </Property>
      </Properties>
    </Class>
    
  </Classes>
  
  <Expressions>
    <Expression name="Sum">
      <Description>Computes the sum of a sequence of values.</Description>
      <Remarks>Remarks Placeholder</Remarks>
      <Examples>
        <Example>
          <HeaderRemarks>The following is an example of a `Sum` expression.</HeaderRemarks>
          <ExampleCode>int[] initValues = new int[] { 1, 2, 3, 4, 5 };&#xA;var qry = initValues&#xA;    .AsQueryable()&#xA;    .Select(x => new { strValue = "str", intValue = x })&#xA;    .GroupBy(x => x.strValue);&#xA;&#xA;var result = qry.Select("Sum(intValue)");</ExampleCode>
          <EquivalentCode>int[] initValues = new int[] { 1, 2, 3, 4, 5 };&#xA;var qry = initValues&#xA;    .AsQueryable()&#xA;    .Select(x => new { strValue = "str", intValue = x })&#xA;    .GroupBy(x => x.strValue);&#xA;&#xA;var result = qry.Sum(x => x.intValue);</EquivalentCode>
        </Example>
      </Examples>
    </Expression>

    <Expression name="Contains">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="In">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="First">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="FirstOrDefault">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="Single">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="SingleOrDefault">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="Select">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="Where">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="OrderBy">
      <Description>Placeholder</Description>
    </Expression>

    <Expression name="OrderByDecending">
      <Description>Placeholder</Description>
    </Expression>

  </Expressions>
  
</DynLINQDoc>